# **Maximum Points from Cards Problem**  
### *A Comprehensive Guide*

---

## **1. Problem Statement**
You are given an array of integers representing the points of `n` different cards. You also have an integer `K`, which signifies the number of cards you need to pick. The cards can only be picked from the front or the back of the array, and you cannot skip any cards in between.

### **Objective**
Maximize the total points obtained by picking exactly `K` cards.

### **Example**
Given the array:  
`points = [6, 2, 3, 4, 1, 7]`  
and `K = 4`, possible selections include:
- Picking the first four cards: `6 + 2 + 3 + 4 = 15`
- Picking the last four cards: `2 + 3 + 4 + 1 = 10`
- Picking two from the front and two from the back: `6 + 2 + 1 + 7 = 16`

The maximum points obtainable is **16**.

---

## **2. Approach**
The problem can be solved using a **sliding window** technique. The idea is to maintain a sum of points from the left and right ends of the array while adjusting the number of cards picked from each side.

### **Steps**:
1. **Initialize Variables**:
   - `left_sum`: Sum of the first `K` cards.
   - `right_sum`: Initially set to 0.
   - `max_sum`: To keep track of the maximum points obtained.

2. **Calculate Initial Left Sum**:
   - Compute the sum of the first `K` cards.

3. **Iterate to Adjust Picks**:
   - For each possible configuration of picking cards:
     - Remove one card from the left and add one from the right.
     - Update the `max_sum` accordingly.

4. **Return the Maximum Sum**.

---

## **3. Pseudocode**
```plaintext

```

---

## **4. Python Code Implementation**
```python
def maxScore(arr, k):
    #[1, 2, 3, 5, 1, 2]
    lsum = sum(arr[0:k])
    rsum = 0
    maxsum = lsum
    
    for i in range(0, k):
        lsum -= arr[k-1 - i] # currently 5 as index 3 = 4-1-0(i)
        rsum += arr[-1 -i] # currently last element 2 as index -1 = -1 - 0(i)
        maxsum = max(maxsum, lsum + rsum)
    return maxsum
    
if __name__ == "__main__":
    arr = [1, 2, 3, 5, 10, 2]
    k = 4
    ans = maxScore(arr, k)
    print(ans)
```

---

## **5. Complexity Analysis**
- **Time Complexity**: O(K) for the initial left sum and O(K) for the iteration, resulting in O(2K) which simplifies to O(K).
- **Space Complexity**: O(1) as we are using a constant amount of space.

---

## **6. Conclusion**
This approach efficiently calculates the maximum points obtainable by leveraging the sliding window technique. It avoids unnecessary complexity by using simple arithmetic operations and maintains clarity in the solution.

If you found this guide helpful, please consider liking and subscribing for more content!
