# **Maximum Points from Cards Problem**  
### *A Comprehensive Guide*

---

## **1. Problem Statement**
You are given an array of integers representing the points of `n` different cards. You also have an integer `K`, which signifies the number of cards you need to pick. The cards can only be picked from the front or the back of the array, and you cannot skip any cards in between.

### **Objective**
Maximize the total points obtained by picking exactly `K` cards.

### **Example**
Given the array:  
`points = [6, 2, 3, 4, 1, 7]`  
and `K = 4`, possible selections include:
- Picking the first four cards: `6 + 2 + 3 + 4 = 15`
- Picking the last four cards: `2 + 3 + 4 + 1 = 10`
- Picking two from the front and two from the back: `6 + 2 + 1 + 7 = 16`

The maximum points obtainable is **16**.

---

## **2. Approach**
The problem can be solved using a **sliding window** technique. The idea is to maintain a sum of points from the left and right ends of the array while adjusting the number of cards picked from each side.

### **Steps**:
1. **Initialize Variables**:
   - `left_sum`: Sum of the first `K` cards.
   - `right_sum`: Initially set to 0.
   - `max_sum`: To keep track of the maximum points obtained.

2. **Calculate Initial Left Sum**:
   - Compute the sum of the first `K` cards.

3. **Iterate to Adjust Picks**:
   - For each possible configuration of picking cards:
     - Remove one card from the left and add one from the right.
     - Update the `max_sum` accordingly.

4. **Return the Maximum Sum**.

---

## **3. Pseudocode**
```plaintext
function maxPoints(points, K):
    n = length of points
    left_sum = 0
    right_sum = 0
    max_sum = 0

    // Calculate initial left sum
    for i from 0 to K-1:
        left_sum += points[i]
    
    max_sum = left_sum

    // Iterate to adjust picks
    for i from K-1 down to 0:
        left_sum -= points[i]  // Remove one from the left
        if (n - (K - (K - i)) >= 0):  // Ensure right index is valid
            right_sum += points[n - (K - i)]  // Add one from the right
        max_sum = max(max_sum, left_sum + right_sum)

    return max_sum
```

---

## **4. Python Code Implementation**
```python
def maxPoints(points, K):
    n = len(points)
    left_sum = 0
    right_sum = 0
    max_sum = 0

    # Calculate initial left sum
    for i in range(K):
        left_sum += points[i]
    
    max_sum = left_sum

    # Iterate to adjust picks
    for i in range(K - 1, -1, -1):
        left_sum -= points[i]  # Remove one from the left
        if n - (K - (K - i)) >= 0:  # Ensure right index is valid
            right_sum += points[n - (K - i)]  # Add one from the right
        max_sum = max(max_sum, left_sum + right_sum)

    return max_sum

# Example usage
points = [6, 2, 3, 4, 1, 7]
K = 4
print(maxPoints(points, K))  # Output: 16
```

---

## **5. Complexity Analysis**
- **Time Complexity**: O(K) for the initial left sum and O(K) for the iteration, resulting in O(2K) which simplifies to O(K).
- **Space Complexity**: O(1) as we are using a constant amount of space.

---

## **6. Conclusion**
This approach efficiently calculates the maximum points obtainable by leveraging the sliding window technique. It avoids unnecessary complexity by using simple arithmetic operations and maintains clarity in the solution.

If you found this guide helpful, please consider liking and subscribing for more content!
